{"version":3,"file":"background.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://chrome-studio-extension/./src/background/background.ts"],"sourcesContent":["chrome.runtime.onMessage.addListener(function (msg) {\n    if (msg.external_url) {\n        createExternalMedia(msg.external_url);\n    }\n    if (msg.captionDownloadTitle) {\n        chrome.storage.local\n            .get([\"authToken\", \"userID\", \"caption\", \"studioDomain\"])\n            .then((result) => {\n            if (result.authToken && result.userID && result.caption) {\n                const captionFile = new Blob([result.caption], { type: \"text/srt\" });\n                const formData = new FormData();\n                formData.append(\"caption_file\", captionFile);\n                fetch(`${result.studioDomain}/api/public/v1/media/search?title=${msg.captionDownloadTitle}`, {\n                    method: \"GET\",\n                    headers: {\n                        Authorization: `Bearer user_id=\"${result.userID}\",token=\"${result.authToken}\"`,\n                    },\n                }).then((res) => res.json().then((data) => {\n                    fetch(`${result.studioDomain}/api/public/v1/media/${data.media[0].id}/caption_files?srclang=en`, {\n                        method: \"POST\",\n                        headers: {\n                            Authorization: `Bearer user_id=\"${result.userID}\",token=\"${result.authToken}\"`,\n                        },\n                        body: formData,\n                    });\n                }));\n            }\n            else {\n                console.error(\"Not authorized\");\n            }\n        });\n    }\n});\n// I have to use fetch manually here, because axios is based on XMLHttpRequest\nfunction createExternalMedia(url) {\n    chrome.storage.local\n        .get([\"authToken\", \"userID\", \"studioDomain\"])\n        .then((result) => {\n        if (result.authToken && result.userID) {\n            fetch(`${result.studioDomain}/api/media_management/collections/5/media`, {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer user_id=\"${result.userID}\",token=\"${result.authToken}\"`,\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({\n                    external_url: url,\n                }),\n            });\n        }\n        else {\n            console.error(\"Not authorized\");\n        }\n    });\n}\nchrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {\n    // Prevent double firing of event - extension should run once on complete.\n    if (changeInfo.status === \"complete\") {\n        chrome.webRequest.onCompleted.addListener(initOnce, {\n            urls: [\"https://www.youtube.com/*\"],\n        });\n    }\n});\nfunction initOnce(details) {\n    if (details.url.includes(\"timedtext?v\")) {\n        fetch(details.url, {\n            method: \"GET\",\n        }).then((res) => {\n            res.json().then((body) => downloadCaption(body));\n        });\n        chrome.webRequest.onCompleted.removeListener(initOnce);\n    }\n}\nfunction downloadCaption(json) {\n    const getSegments = (events) => {\n        const segments = [];\n        let segmentText = \"\";\n        let segment = {\n            startTimeMs: 0,\n        };\n        events.forEach((evt) => {\n            // check whether it is manually uploaded CC or not\n            if (!evt.wWinId && evt.segs) {\n                segment.startTimeMs = evt.tStartMs;\n                segment.endTimeMs = evt.tStartMs + evt.dDurationMs;\n                (evt.segs || []).forEach((seg) => {\n                    const text = seg.utf8;\n                    if (text && text !== \"\\n\") {\n                        segmentText += text || \"\";\n                    }\n                });\n                segment.text = segmentText;\n                segments.push(segment);\n                segment = {};\n                segmentText = \"\";\n                return;\n            }\n            // Below code is a fall back for Auto Generated CC\n            if (!evt.aAppend) {\n                segment.startTimeMs = evt.tStartMs;\n                (evt.segs || []).forEach((seg) => {\n                    const text = seg.utf8;\n                    if (text && text !== \"\\n\") {\n                        segmentText += text || \"\";\n                    }\n                });\n            }\n            else {\n                segment.endTimeMs = evt.tStartMs;\n                segment.text = segmentText;\n                segments.push(segment);\n                segment = {};\n                segmentText = \"\";\n            }\n        });\n        return segments;\n    };\n    const YTCaptionLines = getSegments(json.events);\n    const convertToStrTime = (ms) => {\n        let seconds = Math.floor(ms / 1000);\n        ms = ms % 1000;\n        const milliseconds = ms;\n        let minutes = Math.floor(seconds / 60);\n        seconds = seconds % 60;\n        const hours = Math.floor(minutes / 60);\n        minutes = minutes % 60;\n        // return format: 00:00:06,319\n        return `${padZero([hours, minutes, seconds]).join(\":\")},${padZero([milliseconds], true)[0]}`;\n    };\n    const padZero = (numList, ms) => {\n        if (!Array.isArray(numList))\n            return [];\n        if (ms) {\n            const milliseconds = numList[0];\n            if (milliseconds >= 100) {\n                return [milliseconds];\n            }\n            else if (milliseconds <= 99 && milliseconds >= 10) {\n                return [`0${milliseconds}`];\n            }\n            else {\n                return [`00${milliseconds}`];\n            }\n        }\n        return numList.map((num) => {\n            if (+num >= 10)\n                return `${num}`;\n            return `0${num}`;\n        });\n    };\n    const convertSegmentsToSrt = (segments) => {\n        let srtString = \"\";\n        segments.forEach((segment, index) => {\n            const startTime = convertToStrTime(segment.startTimeMs);\n            const endTime = convertToStrTime(segment.endTimeMs);\n            const text = \"\" +\n                (index + 1) +\n                \"\\r\\n\" +\n                startTime +\n                \" --> \" +\n                endTime +\n                \"\\r\\n\" +\n                segment.text +\n                \"\\r\\n\\r\\n\";\n            srtString += text;\n        });\n        return srtString;\n    };\n    const file = convertSegmentsToSrt(YTCaptionLines);\n    if (file) {\n        // adding a plus button to page to add a plus button to YT player for adding the caption to Studio media\n        // to do this a message will deliver the new to content script\n        chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\n            chrome.tabs.sendMessage(tabs[0].id, { captionStatus: \"ready\" });\n        });\n        chrome.storage.local.set({ caption: file });\n    }\n}\n"],"names":[],"sourceRoot":""}